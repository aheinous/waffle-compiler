


static fn voidrtn: void (){

}

fn noreturntype : void ()  {


}



# if (someGarbage()) {

}
# else {
	x:int = 3;

	fn thing:(){
		#if whatever() {

		}
	}
}



class Stuff {
	//fn init(x:int, y:int, z:int){

	//}

	x:i32 = 100;
	z:i8;



	fn thing:(){
		int:x;
	}

	fn other:() {

	}
}



fn classTest:(){
	s:Stuff =  Stuff();
	s.x.y = 100;
	//x = 5 + s.z.y;

	x.s()  = y.z(500);

	if blah {
		x:somevar = 0;
	}


}





# while(x) {
	y:int = 3;
}

fn main:int() {

	x:#int;
	y:#int = 10;

	p:&int;
	pp : &&int;
	return 0;
}


fn main:int() {

	# while(100) {

	}



}

x :float  = 5;

fn a:int(){}

fn b:void(){}

fn c:(){


	for x: in someIter() {

	}


	for x:u8 in someIter() {

	}


	for x:u8 in someInit() .. 1000  .. otherThing{

	}


}


it iteratorExample: u8 (n:u8) {
	for x:int in 0..n {
		yield x;
		yield 2*x;
	}
}





x: u32 = 0b1101_0010;
x:u64 = 0xbeef_DEAD;
//x:u32 = a;
x:u8 = 0o777;
x:int = 102_321_987;



arr:int[];
arr:int[4];
arr:int[] = :int[4]{};
arr:int[] = :{1,2,3,4};

dec make_special: (cls:#class) {
	# for methName: in cls.getMethodNames() {
		//method = cls.methods[methodName]

		fn wrapped: #(method.returnType) (VARGS) {
			# for var: in VARGS {
				print(#(var.name + ": " + var.type + " + ") + var.value);
			}
			method(expand(VARGS));
		}
	}
}
