
%import common.ESCAPED_STRING
%import common.SIGNED_FLOAT
%import common.SIGNED_INT
%import common.CNAME
%import common.WS
%import common.C_COMMENT
%import common.CPP_COMMENT

%ignore WS
%ignore C_COMMENT
%ignore CPP_COMMENT




?start: program


program: global_statement*

?block : "{" statement* "}"
?global_block : "{" global_statement* "}"



?global_statement: class_decl
				| func
				| mixin ";" -> mixin_statement
				| decl ";"
				| decl_init ";"
				| global_static_if_elif
				| global_static_while_loop
				| global_static_for_loop

?statement: 		if_statement
					| mixin ";" -> mixin_statement
					| static_if_elif
					| while_loop
					| static_while_loop
					| for_loop
					| static_for_loop
					| for_each_loop
					| rtn ";"
					| decl ";"
					| decl_init ";"
					| block
					| assign ";"
					| func_call ";"
					| "plocal"  ";" -> plocal




decl: sym ":" type
decl_init: sym ":" type "=" exprn
assign: lvalue "=" exprn


class_decl: "class" sym "{" class_content "}"
class_content: class_content_item*
?class_content_item: decl_init ";"
						| decl ";"
						| func
						| method
						| vmethod


// func: "func" sym "(" decl_arg_list ")"  ":" rtn_type block

func: _func{"func"}
method: _func{"method"}
vmethod: _func{"vmethod"}


_func{kwd}: kwd sym "(" decl_arg_list ")"  ":" rtn_type block
decl_arg_list: [ sym ":" type ("," sym ":" type)*]

?rtn_type:  type |  void
void:


func_call: sym "(" call_arg_list ")"
call_arg_list: [ exprn ("," exprn )*]


// _if_elif{ mods, blk }: mods "if"  exprn  blk ( mods "elif"  exprn  blk)* [ mods "else"  blk  ]
// if_elif: 				_if_elif{ void , block}
// static_if_elif: 		_if_elif{ "#" , block}
// global_static_if_elif: 	_if_elif{ "#" , global_block}


if_statement: _if_statement{ void, block}
static_if_elif: _if_statement{ COMPILE_TIME, block}
global_static_if_elif: _if_statement{ COMPILE_TIME, global_block}


_if_statement{mods, blk}: mods "if" exprn blk _after_if{mods,blk}?
elif_statement{mods, blk}: mods "elif" exprn blk _after_if{mods, blk}?
else_statement{mods, blk}: mods "else" blk


_after_if{mods, blk}: else_statement{mods, blk}
		| elif_statement{mods, blk}





_while_loop{mod, blk}: mod "while" exprn blk
while_loop: 				_while_loop{void, block}
static_while_loop: 			_while_loop{COMPILE_TIME, block}
global_static_while_loop: 	_while_loop{COMPILE_TIME, global_block}



_for_loop{ mod, blk} : mod "for" for_init ";" for_cond";" for_incr blk
for_loop: 				_for_loop{ void, block}
static_for_loop: 		_for_loop{ COMPILE_TIME, block}
global_static_for_loop: _for_loop{ COMPILE_TIME, global_block}



for_init: for_statement
for_cond: [exprn]
for_incr: for_statement
?for_statement: decl
				| decl_init
				| assign
				|

for_each_loop: "fore" decl "in" exprn block

?mixin: "mixin" "(" exprn ")"

rtn: "return" [exprn]





?exprn: or_exprn

?or_exprn: and_exprn
	| or_exprn  "or" and_exprn

?and_exprn: equal_test
	| and_exprn  "and" equal_test

?equal_test: gt_lt_test
	| equal_test "==" gt_lt_test -> eq
	| equal_test "!=" gt_lt_test -> not_eq

?gt_lt_test: sum
	| gt_lt_test ">" sum ->  gt
	| gt_lt_test ">=" sum -> gteq
	| gt_lt_test "<" sum ->  lt
	| gt_lt_test "<=" sum -> lteq

?sum: product
	| sum "+" product -> add
	| sum "-" product -> sub



?product: item
		| product "*" item -> mult
		| product "/" item -> div


?item: SIGNED_INT -> integer
		| SIGNED_FLOAT -> floating_pt
		| "+" item
		| "-" item -> neg
		| "(" exprn ")"
		| ESCAPED_MULTILINE_STRING -> multiline_string
		| ESCAPED_STRING -> string
		| lvalue


?lvalue: dot_exprn

?dot_exprn: lvalue_item
			| dot_exprn "." lvalue_item



?lvalue_item: sym
			| mixin -> mixin_exprn
			| func_call


// ADDRS : "&"+

type : type_modifier* CNAME


?type_modifier 	: AMP+ -> address_of
				| COMPILE_TIME -> compile_time

COMPILE_TIME : "#"
DEREF: "*"
AMP : "&"
sym: CNAME


_MULTILINE_STRING_INNER: /(.|\n)*?/
_MULTILINE_STRING_ESC_INNER: _MULTILINE_STRING_INNER /(?<!\\)(\\\\)*?/
ESCAPED_MULTILINE_STRING : "\"\"\"" _MULTILINE_STRING_ESC_INNER "\"\"\""

